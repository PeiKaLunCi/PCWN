# -*- coding: utf-8 -*-
"""pca_wavelet_utils.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18Ijd8tNk_lv-rYl0-CXBl9_KlrGdjrbO
"""

# Commented out IPython magic to ensure Python compatibility.
#try:
  # %tensorflow_version only exists in Colab.
#   %tensorflow_version 2.x
#except Exception:
#  pass
import tensorflow as tf
device_name = tf.test.gpu_device_name()
if device_name != '/device:GPU:0':
  print('GPU device not found')#raise SystemError('GPU device not found')#
print('Found GPU at: {}'.format(device_name))

def setupfilters3D(channels):
  filts = tf.constant([[1.0/16.0, 4.0/16.0, 6.0/16.0, 4.0/16.0, 1.0/16.0], [0.0, -1.0/4.0, 2.0/4.0, -1.0/4.0, 0.0], [0.0, 1.0/2.0, 0.0, -1.0/2.0, 0.0]], dtype=tf.float64)
  #filts = tf.constant([[1.0/4.0, 2.0/4.0, 1.0/4.0], [-1.0/4.0, 2.0/4.0, -1.0/4.0], [1.0/2.0, 0.0, -1.0/2.0]], dtype=tf.float64)
  filts3D = []
  for k in range(channels):
    for i in range(3):
      for j in range(3):
        filt2D = tf.pad([tf.tensordot(filts[i], filts[j], axes=0)],[[k,channels-k-1],[0,0],[0,0]],mode="CONSTANT", constant_values=0)
        filts3D.append(filt2D)
  filters = tf.stack(filts3D)
  #print(filts3D[0])
  #filts = tf.transpose(tf.constant([[1.0/16.0, 4.0/16.0, 6.0/16.0, 4.0/16.0, 1.0/16.0], [0.0, -1.0/4.0, 2.0/4.0, -1.0/4.0, 0.0], [0.0, -1.0/2.0, 0.0, 1.0/2.0, 0.0]]))
  #filter = tf.transpose(tf.tile([filts],[1, channels, 1]),perm=[2,0,1])
  #filter = tf.tile([filts],[channels, channels, 1])
  #filter = tf.pad([filts],[[]])
  #filter = tf.transpose(filter,perm=[2,0,1])
  
  return filters

def filterImg3D(image, filts=None):
  if filts is None:
    filts = setupfilters3D(image.shape[2])
    filts = tf.transpose(filts,[2,3,1,0])
  #img = tf.transpose([img],[0,1,2,3])
  #print(img.shape)
  img = tf.pad([image],[[0,0],[2,2],[2,2],[0,0]],"REFLECT")
  img = tf.nn.conv2d(img,filts,[1,2,2,1],'VALID',data_format='NHWC')
  return img[0]

def setupInverseFilters3D(channels):
  #filts = tf.constant([[0.0,0.0,1.0,1.0, 0.0,0.0], [-1.0/8.0,-1.0/8.0,10.0/8.0,-6.0/8.0,-1.0/8.0,-1.0/8.0], [1.0/16.0,1.0/16.0, 0.0, -16.0/16.0, -1.0/16.0, -1.0/16.0]], dtype=tf.float64)
  #smooth = [0.05425363410909881, 0.04876340346627686, 0.43560658468724506, 0.9602016399102736, 0.4356065846872451, 0.048763403466276806, 0.054253634109098454] 
  #even = [-0.09611135145790654, -0.1528436732501488, -0.3879374658649768, 1.2676579192007236, -0.38793746586497696, -0.15284367325014991, -0.09611135145790638] 
  #odd = [-0.1012734566642763, -0.052924601287011944, -0.5882279747238891, -1.457167719820518e-16, 0.5882279747238888, 0.05292460128701214, 0.10127345666427592] 
  smooth = [0.0,      0.0,        1.0/16.0,   0.5,      14.0/16.0,  0.5,       1.0/16.0,   0.0,      0.0]
  even = [-1.0/128.0, -1.0/16.0, -10.0/64.0, -7.0/16.0, 85.0/64.0, -7.0/16.0, -10.0/64.0, -1.0/16.0, -1.0/128.0]
  odd = [1.0/256.0,  1.0/32.0,  15.0/128.0,17.0/32.0, 0.0,      -17.0/32.0,  -15.0/128.0, -1.0/32.0,  -1.0/256.0]
  #smooth = [0.5,1.0,0.5]
  #even = [-0.5,1.0,-0.5]
  #odd = [-0.5,0.0,0.5]
  filts = tf.constant([smooth, even, odd], dtype=tf.float64)
  
  filts3D = []

  for i in range(3):
    for j in range(3):
      filt2D = tf.tensordot(filts[i], filts[j], axes=0)
      filts3D.append(filt2D)
  filters = []
  for k in range(channels):
    filter = tf.pad(filts3D,[[k*9,(channels-k-1)*9],[0,0],[0,0]],mode="CONSTANT", constant_values=0)
    filters.append(filter)
  filters = tf.stack(filters)
  #print(filts3D[0])
  #filts = tf.transpose(tf.constant([[1.0/16.0, 4.0/16.0, 6.0/16.0, 4.0/16.0, 1.0/16.0], [0.0, -1.0/4.0, 2.0/4.0, -1.0/4.0, 0.0], [0.0, -1.0/2.0, 0.0, 1.0/2.0, 0.0]]))
  #filter = tf.transpose(tf.tile([filts],[1, channels, 1]),perm=[2,0,1])
  #filter = tf.tile([filts],[channels, channels, 1])
  #filter = tf.pad([filts],[[]])
  #filter = tf.transpose(filter,perm=[2,0,1])
  
  return filters

def addToPCA(ten, pca, mean):
  #print("addToPCA types", ten.dtype,pca.dtype,mean.dtype)
  mat = tf.reshape(ten,[-1,ten.shape[2]])
  cov = tf.tensordot(mat,mat,[0,0])
  m = tf.ones(mat.shape[0], dtype=tf.float64)
  m = tf.linalg.matvec(mat,m, transpose_a=True)
  pca = pca+cov
  mean=mean+m
  
  return pca, mean

def completePCA(pca, mean):
  mouter = tf.tensordot(mean, mean, axes=0)
  pca -= mouter
  s, u, v = tf.linalg.svd(pca)
  #s, u = tf.linalg.eigh(pca)
  #print("s.shape",s.shape)
  #print("u.shape",u.shape)
  #s = tf.reverse(s, [0])
  #u = tf.reverse(u, [0])
  #u = tf.transpose(u,[1,0]) #test
  return s,u #,v

"""Filters for seperable implementation"""

def setupFilts1D():
   filts = tf.constant([[1.0/16.0, 4.0/16.0, 6.0/16.0, 4.0/16.0, 1.0/16.0], [0.0, -1.0/4.0, 2.0/4.0, -1.0/4.0, 0.0], [0.0, 1.0/2.0, 0.0, -1.0/2.0, 0.0]], dtype=tf.float64)
   smooth = [0.0,      0.0,        1.0/16.0,   0.5,      14.0/16.0,  0.5,       1.0/16.0,   0.0,      0.0]
   even = [-1.0/128.0, -1.0/16.0, -10.0/64.0, -7.0/16.0, 85.0/64.0, -7.0/16.0, -10.0/64.0, -1.0/16.0, -1.0/128.0]
   odd = [1.0/256.0,  1.0/32.0,  15.0/128.0,17.0/32.0, 0.0,      -17.0/32.0,  -15.0/128.0, -1.0/32.0,  -1.0/256.0]
   invfilts = tf.constant([smooth, even, odd], dtype=tf.float64)
   return filts, invfilts

import numpy as np
def borderMultiplier(shape, xAxis):
  mulval = np.ones(shape)
  if (xAxis):
    for i in range(3):
      for j in range(shape[0]):
        for k in range(int(shape[2]/3)):
          mulval[j,i,2+3*k]=-1
          mulval[j,shape[1]-i-1,2+3*k]=-1
  else:
    for i in range(3):
      for j in range(shape[1]):
        for k in range(int(shape[2]/3)):
          mulval[i,j,2+3*k]=-1
          mulval[shape[0]-i-1,j,2+3*k]=-1

  return mulval

from tensorflow.keras import backend as K
from tensorflow.keras.layers import Layer

class Conv2DTransposeSeparableLayer(Layer):

    def __init__(self, input_shape, **kwargs):
        self.filters, self.invfilters = setupFilts1D()
        #print("input_shape",input_shape)
        self.input_shapeX = [input_shape[0],input_shape[1]+6,int(input_shape[2])]
        self.tfmultx = borderMultiplier(self.input_shapeX,True)
        self.input_shapeY = [input_shape[0]+6,input_shape[1]*2,int(input_shape[2]/3)]
        self.tfmulty = borderMultiplier(self.input_shapeY,False)
        
        super(Conv2DTransposeSeparableLayer, self).__init__(**kwargs)

    #@classmethod
    #def from_config(cls, config, custom_objects=None):
    #  return {'input_shapeX': self.input_shapeX,
    #          'tfmultx':self.tfmultx,
    #          'input_shapeY':self.input_shapeY,
    #          'tfmulty':self.tfmulty}

    def get_config(self):
      return {'input_shapeX': self.input_shapeX,
              'tfmultx':self.tfmultx,
              'input_shapeY':self.input_shapeY,
              'tfmulty':self.tfmulty}

    def build(self, input_shape):
        super(Conv2DTransposeSeparableLayer, self).build(input_shape)

    def call(self, inputs):
        #output = tf.pad(inputs,[[2,2],[0,0],[0,0]],"REFLECT")#Probably need to deal with different batch sizes
        #print("inputs.shape",inputs.shape)
        #print("self.tfmulx.shape",self.tfmultx.shape)
        
        output = self.invFilterImgX(inputs, self.tfmultx)
        #output = tf.pad(output,[[0,0],[2,2],[0,0]],"REFLECT")#Probably need to deal with different batch sizes
        #print("output.shape",output.shape)
        #print("self.tfmuly.shape",self.tfmulty.shape)
        
        output = self.invFilterImgY(output, self.tfmulty)
        

        return output 

    def compute_output_shape(self, input_shape):
        #print("compute_output_shape", input_shape)
        output_shape=input_shape
        output_shape[0]*=2
        output_shape[1]*=2
        output_shape[2] = int(output_shape[2]/9)
        return (output_shape)

        import numpy as np

    def invFilterImgX(self,image, tfmulval):
      #img = tf.cast(image, tf.float32)/255.0
      #print(img.dtype)
      img = tf.pad(image,[[0,0],[0,0],[3,3],[0,0]],"SYMMETRIC")#"REFLECT")
      #mulval = np.ones(img.shape)
      #for i in range(2):
      #  for j in range(img.shape[0]):
      #    for k in range(int(img.shape[2]/3)):
      #      mulval[j,i,1+3*k]=-1
      #      mulval[j,img.shape[1]-i-1,1+3*k]=-1
      #if (tfmulval==None):
      #  mulval = borderMultiplier(img.shape,True)
      #  tfmulval = tf.constant(mulval,dtype=tf.float32,shape=img.shape)
      img = tf.math.multiply(img,tfmulval)
      #filter = setupfilters(3)
      filter, invfilter = setupFilts1D()
      #print("filter",filter)
      
      #print("inv filter",invfilter)
      
      invfilter = tf.transpose([[invfilter]],[0,3,1,2])
      #print("invfilter.shape",invfilter.shape)
      #print("img.shape",img.shape)
      #im = tf.transpose([[img[:,:,0]]],[0,2,3,1])
      
      #print("im.shape",im.shape)
      #img = tf.nn.depthwise_conv2d([img],filter,[1,2,2,1],'VALID',data_format='NHWC')
      #s = img.shape
      #outimg = tf.zeros([s[0],s[1],s[2]*3])
      outputs = []
      for i in range(int(img.shape[3]/3)):
        slice = tf.gather(img,[3*i+0,3*i+1,3*i+2],axis=3)
        #print("slice.shape",slice.shape)
        #im = tf.transpose([[img[:,:,i]]],[0,2,3,1])
        im = tf.nn.conv2d_transpose(slice,invfilter,[img.shape[0],img.shape[1],img.shape[2]*2+7,1],[1,2],padding='VALID',data_format='NHWC')
        #recon = tf.nn.conv2d_transpose([img], invfilt, [1,260,260,3],2,padding='VALID',data_format='NHWC')
        outputs.append(im)
        
      #len(outputs) 16
      #outimg.shape (16, 1, 64, 79, 1)
      #outimg.shape (64, 79, 16)  
      #print("len(outputs)",len(outputs))
      outimg = tf.stack(outputs)
      #print("outimg.shape",outimg.shape)
      
      outimg = tf.transpose(outimg, perm=[1,2,3,0,4])[:,:,:,:,0]
      #print("outimg.shape",outimg.shape)
      
      return outimg[:,:,10:outimg.shape[2]-9,:]#was 8, -7

    def invFilterImgY(self, image, tfmulval):
      img = tf.pad(image,[[0,0],[3,3],[0,0],[0,0]],"SYMMETRIC")#"REFLECT")
      
      #mulval = borderMultiplier(img.shape,False)
      #tfmulval = tf.constant(mulval,dtype=tf.float32,shape=img.shape)
        
      img = tf.math.multiply(img,tfmulval)
      filter, invfilter = setupFilts1D()
      #print("filter",filter)
      #print("inv filter",invfilter)
      
      invfilter = tf.transpose([[invfilter]],[3,0,1,2])
      #print("invfilter.shape",invfilter.shape)
      #print("img.shape",img.shape)
      #im = tf.transpose([[img[:,:,0]]],[0,2,3,1])
      
      #print("im.shape",im.shape)
      #img = tf.nn.depthwise_conv2d([img],filter,[1,2,2,1],'VALID',data_format='NHWC')
      #s = img.shape
      #outimg = tf.zeros([s[0],s[1],s[2]*3])
      outputs = []
      for i in range(int(img.shape[3]/3)):
        slice = tf.gather(img,[3*i+0,3*i+1,3*i+2],axis=3)
        #print("slice.shape",slice.shape)
        #im = tf.transpose([[img[:,:,i]]],[0,2,3,1])
        im = tf.nn.conv2d_transpose(slice,invfilter,[img.shape[0],img.shape[1]*2+7,img.shape[2],1],[2,1],padding='VALID',data_format='NHWC')
        #recon = tf.nn.conv2d_transpose([img], invfilt, [1,260,260,3],2,padding='VALID',data_format='NHWC')
        outputs.append(im)
        
      #print("len(outputs)",len(outputs))
      outimg = tf.stack(outputs)
      #print("outimg.shape",outimg.shape)
      #len(outputs) 10
      #outimg.shape (10, 1, 79, 32, 1)
      #outimg.shape (79, 32, 10)
      outimg = tf.transpose(outimg, perm=[1,2,3,0,4])[:,:,:,:,0]
      #print("outimg.shape",outimg.shape)
      outimg = outimg[:,10:outimg.shape[1]-9,:,:]#8,-7
      #print("outimg.shape",outimg.shape)
      
      return outimg

from tensorflow.keras import backend as K
from tensorflow.keras.layers import Layer

class BiasLayer(Layer):

    def __init__(self, bias, data_format="channels_last", **kwargs):
        self.data_format = data_format
        self.bias = bias
        super(BiasLayer, self).__init__(**kwargs)

    def get_config(self):
      return {'data_format': self.data_format,
              'bias':self.bias}

    def build(self, input_shape):
        super(BiasLayer, self).build(input_shape)

    def call(self, inputs):
        if self.data_format is "channels_last":
            #(batch, depth, rows, cols, channels)
            #print("BiasLayer:inputs.shape",inputs.shape)
            #print("BiasLayer:bias.shape",self.bias.shape)
            output = tf.nn.bias_add(inputs,self.bias,'NDHWC')
        elif self.data_format is "channels_first":
            #(batch, channels, depth, rows, cols)
            output = tf.nn.bias_add(inputs,self.bias,'NCDHW')

        return output 

    def compute_output_shape(self, input_shape):
        #print("compute_output_shape", input_shape)
        return (input_shape)

from tensorflow.keras import backend as K
from tensorflow.keras.layers import Layer

class SymmetricUnPadding2D(Layer):

    def __init__(self, output_dim, padding=[1,1,1,1], 
                 data_format="channels_last", **kwargs):
        self.output_dim = output_dim
        self.data_format = data_format
        self.padding = padding
        super(SymmetricUnPadding2D, self).__init__(**kwargs)

    def get_config(self):
      return {'output_dim': self.output_dim,
              'data_format':self.data_format,
              'padding':self.padding}

    def build(self, input_shape):
        super(SymmetricUnPadding2D, self).build(input_shape)

    def call(self, inputs):
        if self.data_format is "channels_last":
            #(batch, depth, rows, cols, channels)
            output = inputs[:,self.padding[0]:inputs.shape[1]-self.padding[1],self.padding[2]:inputs.shape[2]-self.padding[3],:]
            #print("unpadding output shape",output.shape)
            return (output)
        elif self.data_format is "channels_first":
            #(batch, channels, depth, rows, cols)
            output = inputs[:,:,self.padding[0]:inputs.shape[1]-self.padding[1],self.padding[2]:inputs.shape[2]-self.padding[3]]
            #print("unpadding output shape",output.shape)
            return (output)

    def compute_output_shape(self, input_shape):
        #print("compute_output_shape", input_shape)
        return (input_shape[0], self.output_dim)

from tensorflow.keras import backend as K
from tensorflow.keras.layers import Layer

class SymmetricPadding2D(Layer):

    def __init__(self, output_dim, padding=[1,1], 
                 data_format="channels_last", **kwargs):
        self.output_dim = output_dim
        self.data_format = data_format
        self.padding = padding
        super(SymmetricPadding2D, self).__init__(**kwargs)

    def get_config(self):
      return {'output_dim': self.output_dim,
              'data_format': self.data_format,
              'padding': self.padding}

    def build(self, input_shape):
        super(SymmetricPadding2D, self).build(input_shape)

    def call(self, inputs):
        if self.data_format is "channels_last":
            #(batch, depth, rows, cols, channels)
            pad = [[0,0]] + [[i,i] for i in self.padding] + [[0,0]]
        elif self.data_format is "channels_first":
            #(batch, channels, depth, rows, cols)
            pad = [[0, 0], [0, 0]] + [[i,i] for i in self.padding]

        #print("pad",pad)
        #print("padding inputs.shape",inputs.shape,"pad",pad)
        paddings = tf.constant(pad)
        out = tf.pad(inputs, paddings, "SYMMETRIC")#"REFLECT")
        #print("pad out shape", out.shape)
        return out 

    def compute_output_shape(self, input_shape):
        #print("compute_output_shape", input_shape)
        return (input_shape[0], self.output_dim)

import numpy as np
def reverse(x,y):
  #print("reversing x.shape, y.shape", x.shape,y.shape)#why does this prrint only once??
  
  z = tf.reverse(x,[1])
  return z,y

def build(dataset, channels = 3, count = 6, samplesize=-1, keep_percent = 0.2, flip=False, activity_regularizer=None, inverse_activity_regularizer=None):
  keep_percent = 4.0/9.0*pow(keep_percent, 1/float(count))
  #print("keep_percent",keep_percent)
  head = tf.keras.Sequential()
  head.run_eagerly=True
  invhead = tf.keras.Sequential()
  invlist = []
  invbinit = tf.constant_initializer(np.zeros(3))
  inv_act=None

  if samplesize<0:
    subset = dataset
    samplesize=len(list(subset))
  else:
    subset = dataset.take(samplesize)
  
  #print("subset size", len(list(subset)))
  
  if flip:
    flipped = subset.map(lambda x,y: reverse(x,y))
    #for im in subset:
    #  print("reversing im.shape", im[0].shape)
    #  rev = tf.reverse(im[0], [0])
    #  flipped.append(tf.data.Dataset.from_tensors(rev))
    #for im in flipped:
    #  subset.concatenate(im)
    subset = subset.concatenate(flipped)
    samplesize*=2
  #print("subset size", len(list(subset)))
  it = iter(subset)
  meanimg = tf.cast(next(it)[0], tf.float64)#/255.0
  size = meanimg.shape[0]
  IMAGE_SIZE = size
  #if (meanimg.shape[0]!=IMAGE_SIZE):

  for i in range(1,samplesize):
    meanimg += tf.cast(next(it)[0], tf.float64)#/255.0

  meanimg /= float(samplesize)
  head.add(tf.keras.layers.Lambda(lambda x: x-meanimg))
  invlist.append(tf.keras.layers.Lambda(lambda x: x+meanimg))

  for lev in range(count):
    outchan = channels*9
    pca = tf.zeros([outchan,outchan], dtype=tf.float64)
    mean = tf.zeros(outchan, dtype=tf.float64)
    filts3D = setupfilters3D(channels)
    filts3D = tf.transpose(filts3D,[2,3,1,0])#inverse [3,2,0,1]
    invfilts3D = setupInverseFilters3D(channels)
    invfilts3D = tf.transpose(invfilts3D,[2,3,0,1])#[0,2,3,1])

    newsize=size/2
    for image in subset:
      #print("image.dtype",type(image[0]))
      #ten = tf.convert_to_tensor(image[0],dtype=tf.float64)
      img = tf.cast(image[0], tf.float64)#/255.0
      #if lev is 0:
      #  pred = img
      #else:
      img = tf.transpose([img],[0,1,2,3])
      #print("img shape",img.shape)
      pred = head(img)[0]
      #img = tf.pad([img],[[0,0],[2,2],[2,2],[0,0]],"SYMMETRIC")
      #print("pred.shape",pred.shape)
      filtered = filterImg3D(pred, filts=filts3D)
      pca,mean = addToPCA(filtered, pca, mean)
    #print("Completing",newsize)
    pca = pca/float(newsize*newsize*samplesize)
    mean /= float(newsize*newsize*samplesize)
    #print("pca shape",tf.shape(pca))
    #print("mean",mean)
    s,u = completePCA(pca,mean)
    #print(s)
    keep_channels = int(keep_percent*u.shape[1])#(4.0/9.0)
    #print("keep_channels",keep_channels)
    ufilts = tf.transpose([[[u[:,0:keep_channels]]]],[0,1,2,3,4])
    #print("ufilts.shape",ufilts.shape)
    utfilts = tf.transpose([[[u[:,0:keep_channels]]]],[0,1,2,4,3])
  
    filts3D = tf.transpose([filts3D],[0,3,1,2,4]) #[0,2,3,4,1])
    #print("filts3D.shape",filts3D.shape)
    #invfilts3D = tf.transpose([invfilts3D],[0,1,2,3,4])
    #newinvfilt = tf.nn.conv3d(invfilts3D,utfilts,[1,1,1,1,1],'VALID',data_format='NDHWC')
    newfilt = tf.nn.conv3d(filts3D,ufilts,[1,1,1,1,1],'VALID',data_format='NDHWC')
    filtsOrig = tf.transpose(newfilt[0], [1,2,0,3])#[2,3,1,0] for original filters, [1,0,2,3] almost worked
    numpynewfilt = filtsOrig.numpy()#newfilt.numpy()
    init = tf.constant_initializer(numpynewfilt)
    bias = -tf.linalg.matvec(ufilts,mean, transpose_a=True)[0,0,0]
    binit = tf.constant_initializer(bias.numpy())
    head.add(SymmetricPadding2D(2, input_shape=(int(size),int(size),channels), padding=[2,2]))
    head.add(tf.keras.layers.Conv2D(keep_channels, (5, 5), strides=(2, 2), input_shape=(int(size)+4, int(size)+4, channels), kernel_initializer=init, bias_initializer=binit, dtype=tf.float64,activity_regularizer=activity_regularizer))
  
    invfilts3D = setupInverseFilters3D(channels)
    invfilts3D = tf.transpose([invfilts3D],[0,1,3,4,2])#[0,2,3,1])
    tfilts = tf.transpose(ufilts,[0,1,2,4,3])
    #print("invfilts3D.shape",invfilts3D.shape)
    #print("tfilts.shape",tfilts.shape)
    newinvfilt = tf.nn.conv3d_transpose(invfilts3D,tfilts,[1,channels,9,9,keep_channels],1,padding='VALID',data_format='NDHWC')
    #print("newinvfilt.shape",newinvfilt.shape)
    newinvfilt = newinvfilt[0]
    newinvfilt = tf.transpose(newinvfilt,[1,2,0,3])
    #print("newinvfilt.shape",newinvfilt.shape)
    #print("newfilt",newfilt)
    #IMAGE_SIZE=256
    #filtsInvOrig = tf.transpose(newfilt[0], [1,2,0,3])#[2,3,1,0] for original filters, [1,0,2,3] almost worked
    numpynewinvfilt = newinvfilt.numpy()#newfilt.numpy()
    init = tf.constant_initializer(numpynewinvfilt)
  
    bias = tf.linalg.matvec(ufilts,mean, transpose_a=True)[0,0,0]
    #recon = tf.nn.bias_add(decom, -bias)
    #print("mean.shape",mean.shape)
    #recon = tf.nn.conv2d_transpose([recon], newinvfilt, [1,260,260,3],2,padding='VALID',data_format='NHWC')
    #print("recon.shape", recon.shape)
    #recon = recon[:,2:258,2:258,:]
    #print("input_shape",size,size,channels)
    invlist.append(SymmetricUnPadding2D(2, input_shape=(int(size+4),int(size+4),channels), padding=[8,7,8,7]))
    invlist.append(tf.keras.layers.Conv2DTranspose(channels, (9, 9), strides=(2, 2), output_padding=0, kernel_initializer=init, bias_initializer=invbinit, dtype=tf.float64,activity_regularizer=inv_act))
    invlist.append(SymmetricPadding2D(2, input_shape=(int(size),int(size),channels), padding=[2,2]))
    invbinit = tf.constant_initializer(bias.numpy())
    channels = keep_channels
    size=newsize
    #print("end loop", size)
  #print("bias.shape",bias.shape)
  invlist.append(BiasLayer(bias))
  invlist.append(tf.keras.layers.Activation(inverse_activity_regularizer))

  #invert invlist for reconstruction
  it = reversed(invlist)
  for e in it:
    invhead.add(e)

  return head, invhead

"""Replace Lambda layers with a class to allow saving to file."""

from tensorflow.keras import backend as K
class MeanLayer(tf.keras.layers.Layer):
    def __init__(self, mean, **kwargs):
      super(MeanLayer, self).__init__()
      self.mean = tf.keras.backend.variable(tf.keras.backend.cast_to_floatx(mean), dtype='float64')#[0:mean.shape[0],0:mean.shape[1],0:mean.shape[2]]
      print("self.mean.dtype",self.mean.dtype)
      #print("self.mean[0:10,0:10,0]",self.mean[0:10,0:10,0])
      super(MeanLayer, self).__init__(**kwargs)

    def call(self, inputs):
      return inputs + self.mean
    
    def get_config(self):
      serial_mean = tf.keras.backend.eval(self.mean)#tf.io.serialize_tensor(self.mean)
      print("Getting the config")
      config = super(MeanLayer,self).get_config()#tf.keras.layers.Layer, self
      config.update({'mean': serial_mean})#self.mean})#
      print("config = ", config)
      return config #{'mean': self.mean}

    #@classmethod
    #def from_config(cls, config, custom_objects=None):
    #  serial_mean = config['mean']
    #  
    #  mean = tf.io.serialize_tensor(serial_mean)
    #  me = MeanLayer(mean)
    #  return me #todo, needs checking!!!

"""Build method using 1D convolutions, to better handle borders, in particular the issue with asymmetric forward filters, need to pad the borders with asymmetric flipped values."""

import numpy as np

def build1D(dataset, channels = 3, count = 6, samplesize=-1, keep_percent = 0.2, flip=False, activity_regularizer=None, inverse_activity_regularizer=None, activation_before=False):
  #size = IMAGE_SIZE
  keep_percent = 4.0/9.0*pow(keep_percent, 1/float(count))
  print("keep_percent",keep_percent, flush=True)
  head = tf.keras.Sequential()
  head.run_eagerly=True
  invhead = tf.keras.Sequential()
  invlist = []
  invbinit = tf.constant_initializer(np.zeros(3))
  #inv_act = None #inverse_activity_regularizer
  #if samplesize<0:
  #  subset = dataset
  #  samplesize=len(list(subset))
  #else:
  #  subset = dataset.take(samplesize)
  subset = dataset
  #print("subset size", len(list(subset)))
  
  if flip:
    flipped = subset.map(lambda x,y: reverse(x,y))
    #for im in subset:
    #  print("reversing im.shape", im[0].shape)
    #  rev = tf.reverse(im[0], [0])
    #  flipped.append(tf.data.Dataset.from_tensors(rev))
    #for im in flipped:
    #  subset.concatenate(im)
    subset = subset.concatenate(flipped)
    samplesize*=2
  #print("subset size", len(list(subset)), flush=True)
  it = iter(subset)
  meanimg = tf.cast(next(it)[0], tf.float64)#/255.0
  sizex = meanimg.shape[1]
  IMAGE_SIZE_X = sizex
  sizey = meanimg.shape[0]
  IMAGE_SIZE_Y = sizey

  #if (meanimg.shape[0]!=IMAGE_SIZE):

  for i in range(1,samplesize):
    meanimg += tf.cast(next(it)[0], tf.float64)#/255.0
  print("meanimg.dtype",meanimg.dtype, flush=True)
  meanimg /= float(samplesize)
  head.add(MeanLayer(-meanimg))#tf.keras.layers.Lambda(lambda x: x-meanimg))
  invlist.append(MeanLayer(meanimg))#tf.keras.layers.Lambda(lambda x: x+meanimg))

  for lev in range(count):
    print("Starting level",lev,flush=True)
    outchan = channels*9
    pca = tf.zeros([outchan,outchan], dtype=tf.float64)
    mean = tf.zeros(outchan, dtype=tf.float64)
    filts3D = setupfilters3D(channels)
    filts3D = tf.transpose(filts3D,[2,3,1,0])#inverse [3,2,0,1]
    #invfilts3D = setupInverseFilters3D(channels)
    #invfilts3D = tf.transpose(invfilts3D,[2,3,0,1])#[0,2,3,1])

    newsizex=sizex/2
    newsizey=sizey/2
    for image in subset:
      #print("image.dtype",type(image[0]))
      #ten = tf.convert_to_tensor(image[0],dtype=tf.float32)
      img = tf.cast(image[0], tf.float64)#/255.0
      #if lev is 0:
      #  pred = img
      #else:
      img = tf.transpose([img],[0,1,2,3])
      #print("img shape",img.shape)
      pred = head(img)[0]
      #img = tf.pad([img],[[0,0],[2,2],[2,2],[0,0]],"SYMMETRIC")
      #print("pred.shape",pred.shape)
      filtered = filterImg3D(pred, filts=filts3D)
      pca,mean = addToPCA(filtered, pca, mean)
    print("Completing",newsizex)
    pca = pca/float(newsizex*newsizey*samplesize)
    mean /= float(newsizex*newsizey*samplesize)
    print("pca shape",tf.shape(pca))
    #print("mean",mean)
    s,u = completePCA(pca,mean)
    #print("s",s)
    keep_channels = int(keep_percent*u.shape[1])#(4.0/9.0)
    #s = tf.math.sqrt(s)
    var_explained=0
    var_total = tf.math.reduce_sum(s,0)
    #print("var_total",var_total)
    s = s/var_total
    #print("s after divide",s)
    var_total_post = tf.math.reduce_sum(s,0)
    #print("var_total_post",var_total_post)
    keep_max = channels*(IMAGE_SIZE_Y/filtered.shape[0])*(IMAGE_SIZE_X/filtered.shape[1])
    print("keep_channels",keep_channels, "keep_max", keep_max)
    compcount=0
    while (var_explained<1.0 and compcount<keep_max and compcount<keep_channels):#u.shape[1]):
      var_explained+=s[compcount]
      compcount+=1

    keep_channels = compcount#int(keep_percent*u.shape[1])#(4.0/9.0)
    print("keep_channels",keep_channels)
    ufilts = tf.transpose([[[u[:,0:keep_channels]]]],[0,1,2,3,4])
    print("ufilts.shape",ufilts.shape)
    
  
    filts3D = tf.transpose([filts3D],[0,3,1,2,4]) #[0,2,3,4,1])
    #print("filts3D.shape",filts3D.shape)
    #invfilts3D = tf.transpose([invfilts3D],[0,1,2,3,4])
    #newinvfilt = tf.nn.conv3d(invfilts3D,utfilts,[1,1,1,1,1],'VALID',data_format='NDHWC')
    newfilt = tf.nn.conv3d(filts3D,ufilts,[1,1,1,1,1],'VALID',data_format='NDHWC')
    filtsOrig = tf.transpose(newfilt[0], [1,2,0,3])#[2,3,1,0] for original filters, [1,0,2,3] almost worked
    numpynewfilt = filtsOrig.numpy()#newfilt.numpy()
    init = tf.constant_initializer(numpynewfilt)
    #init = tf.constant_initializer(filts3D.numpy())
    bias = -tf.linalg.matvec(ufilts,mean, transpose_a=True)[0,0,0]
    binit = tf.constant_initializer(bias.numpy())
    if (activation_before):
      head.add(tf.keras.layers.Activation(activity_regularizer))
    
    head.add(SymmetricPadding2D(2, input_shape=(int(sizey),int(sizex),channels), padding=[2,2]))
    head.add(tf.keras.layers.Conv2D(keep_channels, (5, 5), strides=(2, 2), input_shape=(int(sizey)+4, int(sizex)+4, channels),
                                    kernel_initializer=init, bias_initializer=binit))#, activity_regularizer=activity_regularizer))
    if (not activation_before):
      head.add(tf.keras.layers.Activation(activity_regularizer))
    
    #head.add(tf.keras.layers.Conv2D(keep_channels, (5, 5), strides=(2, 2), input_shape=(int(size)+4, int(size)+4, channels), kernel_initializer=init, bias_initializer='zeros'))
    target_shape = [filtered.shape[0],filtered.shape[1],u.shape[1]]
    #print("target_shape", target_shape)
    if (activation_before):
      invlist.append(tf.keras.layers.Activation(inverse_activity_regularizer))
    
    invlist.append(Conv2DTransposeSeparableLayer(target_shape))
    #invfilts3D = setupInverseFilters3D(channels)
    #invfilts3D = tf.transpose([invfilts3D],[0,1,3,4,2])#[0,2,3,1])
    utfilts = tf.transpose([[u[:,0:keep_channels]]],[0,1,3,2])
    #tfilts = tf.transpose(utfilts,[0,1,2,4,3])
    #print("invfilts3D.shape",invfilts3D.shape)
    #print("utfilts.shape",utfilts.shape)
    binit = tf.constant_initializer(mean.numpy())
    kinit = tf.constant_initializer(utfilts.numpy())
    
    #invlist.append(tf.keras.layers.Conv3DTranspose(channels,[keep_channels,1,1],strides=1,padding='VALID', use_bias=True, kernel_initializer=kinit, bias_initializer=binit))
    #invlist.append(tf.keras.layers.Conv2DTranspose(channels,[1,1],strides=1,padding='VALID', use_bias=True, kernel_initializer=kinit, bias_initializer=binit))
    invlist.append(tf.keras.layers.Conv2D(u.shape[0],[1,1],strides=1,padding='VALID', use_bias=True, kernel_initializer=kinit, bias_initializer=binit))
    if (not activation_before):
      invlist.append(tf.keras.layers.Activation(inverse_activity_regularizer))
    
    #newinvfilt = tf.nn.conv3d_transpose(invfilts3D,tfilts,[1,channels,6,6,keep_channels],1,padding='VALID',data_format='NDHWC')
    #print("newinvfilt.shape",newinvfilt.shape)
    #newinvfilt = newinvfilt[0]
    #newinvfilt = tf.transpose(newinvfilt,[1,2,0,3])
    #print("newinvfilt.shape",newinvfilt.shape)
    #print("newfilt",newfilt)
    #IMAGE_SIZE=256
    #filtsInvOrig = tf.transpose(newfilt[0], [1,2,0,3])#[2,3,1,0] for original filters, [1,0,2,3] almost worked
    #numpynewinvfilt = newinvfilt.numpy()#newfilt.numpy()
    #init = tf.constant_initializer(numpynewinvfilt)
  
    #bias = tf.linalg.matvec(ufilts,mean, transpose_a=True)[0,0,0]
    #recon = tf.nn.bias_add(decom, -bias)
    #print("mean.shape",mean.shape)
    #recon = tf.nn.conv2d_transpose([recon], newinvfilt, [1,260,260,3],2,padding='VALID',data_format='NHWC')
    #print("recon.shape", recon.shape)
    #recon = recon[:,2:258,2:258,:]
    #print("input_shape",size,size,channels)
    #invlist.append(SymmetricUnPadding2D(2, input_shape=(int(size),int(size),channels), padding=[2,2]))
    #invlist.append(tf.keras.layers.Conv2DTranspose(channels, (6, 6), strides=(2, 2), output_padding=0, kernel_initializer=init, bias_initializer=invbinit))
    #invbinit = tf.constant_initializer(bias.numpy())
    channels = keep_channels
    sizex=newsizex
    sizey=newsizey
    print("end loop", sizex)
  #print("bias.shape",bias.shape)
  #invlist.append(BiasLayer(bias))

  #invert invlist for reconstruction
  it = reversed(invlist)
  for e in it:
    invhead.add(e)

  return head, invhead
  
